/***************************************************
    Example 3.6
    Driver program for queue functions

/***************************************************/

#include <stdio.h>
#include <stdlib.h>

typedef struct node NODE;
struct node
{
	int          data;
	struct node *next;
};

int main (void)
{
	NODE *dequeue(NODE **queue, NODE **rear);
	void  enqueue(NODE **queue, NODE **rear, int data);

	NODE *queue = NULL, *rear = NULL;
	NODE *front;

	enqueue(&queue, &rear, 3);
	enqueue(&queue, &rear, 4);
	enqueue(&queue, &rear, 5);

	front = dequeue(&queue, &rear);
	if (front)
	{
		printf("Front node of queue is %d\n", front->data);
		free(front);
	}
	else printf("Empty queue!\n");

	front = dequeue(&queue, &rear);
	if (front)
	{
		printf("Front node of queue is %d\n", front->data);
		free(front);
	}
	else printf("Empty queue!\n");


	front = dequeue(&queue, &rear);
	if (front)
	{
		printf("Front node of queue is %d\n", front->data);
		free(front);
	}
	else printf("Empty queue!\n");

	front = dequeue(&queue, &rear);
	if (front)
	{
		printf("Front node of queue is %d\n", front->data);
		free(front);
	}
	else printf("Empty queue!\n");

	return 0;
}
/***************************************************
    Queue Insert: insert at the end
*/
void enqueue(NODE **queue, NODE **rear, int data)
{
	NODE *pnew;

	pnew = (NODE *) malloc(sizeof (NODE));
	if (!pnew)
	{
		printf("... error in enqueue!\n");
		exit(1);
	}
	pnew->data = data;
	pnew->next = NULL;
	if (*queue == NULL) *queue = pnew;
	else (*rear)->next = pnew;
	*rear = pnew;
	return;
}

/***************************************************
    Queue Delete: remove the first node
*/
NODE *dequeue(NODE **queue, NODE **rear)
{
	NODE *first;

	if (*queue == NULL) return NULL;
	first = *queue;
	*queue = (*queue)->next;
	if (*queue == NULL) *rear = NULL;
	first->next = NULL;

	return first;
}


/***************************************************



------------------------------------------------------



 ***************************************************/

 /*******************************************************
    Examples: 3.20 - 3.23
    Driver program to demonstrate the OS Queues Program:
    a singly-linked list of queues
/*******************************************************/

#include <stdio.h>
#include <stdlib.h>  // malloc(), free(), exit()
#include <string.h>

#define DUMMY_TRAILER '\177'
// octal ASCII code of the
// last character in the ASCII table

// queue node
typedef struct request REQUEST;
struct request
{
	char *username;
	long job_id;
	struct request *next;
};

// linked list node
typedef struct service SERVICE;
struct service
{
	char *qname;
	struct request *front;
	struct request *rear;
	struct service *next;  // next node in the list
};

int main (void)
{
	SERVICE *init_list(void);
	void getinfo(char *qname, char *username, long *job_id);
	void insert(SERVICE *serv_ptr, char *qname, char *username, long job_id);
	void traverse(SERVICE *serv_ptr);

	SERVICE *serv_ptr;
	char qname[30], username[20];
	long job_id;

	serv_ptr = init_list();
	while (getinfo(qname, username, &job_id), strcmp(qname, "quit") != 0)
	{
		insert(serv_ptr, qname, username, job_id);
	}
	traverse(serv_ptr);

	return 0;
}

/************************************************************************
    Initialization of a linked list with two
    sentinel nodes
*/
SERVICE *init_list(void)
{
	SERVICE *serv_ptr;

	// allocate the first sentinel node
	serv_ptr = (SERVICE *) malloc(sizeof (SERVICE));
	if (!serv_ptr)
	{
		printf("Error in init_list!\n");
		exit(1);
	}
	serv_ptr->qname = (char *) malloc(1);
	if (!serv_ptr->qname)
	{
		printf("Error in init_list!\n");
		exit(1);
	}
	*serv_ptr->qname = '\0'; // dummy header value

	// allocate the last sentinel node
	serv_ptr->next = (SERVICE *) malloc(sizeof (SERVICE));
	if (!(serv_ptr->next))
	{
		printf("Error in init_list!\n");
		exit(1);
	}
	serv_ptr->next->qname = (char *) malloc(2);
	if (!serv_ptr->next->qname)
	{
		printf("Error in init_list!\n");
		exit(1);
	}
	*serv_ptr->next->qname = DUMMY_TRAILER;
	serv_ptr->next->qname[1] = '\0';
	serv_ptr->next->next = NULL;

	return serv_ptr;
}


/************************************************************************
    Get user input
*/
void getinfo(char *qname, char *username, long *job_id)
{
	char line[512];

	printf("Enter qname username job-id (such as Print1 John 1234): ");
	gets(line);

	if (strcmp(line, "quit") == 0)
		strcpy(qname, "quit");
	else
		sscanf(line, "%s %s %ld", qname, username, job_id);
	return;
}


/************************************************************************
    Insert a new request
*/
void insert(SERVICE *serv_ptr, char *qname, char *username, long job_id)
{
	SERVICE *curr = serv_ptr->next;
	SERVICE *prev = serv_ptr;
	SERVICE *newserv;
	REQUEST *newreq;

	// look for qname
	while (strcmp(qname, curr->qname) > 0)
	{
		prev = curr;
		curr = curr->next;
	}
	if (strcmp(qname, curr->qname) != 0) // Not found: new service!
	{                                    // add a new node to the linked list
		if ((newserv = (SERVICE *)malloc(sizeof(SERVICE))) == NULL)
		{
			printf("Fatal malloc error!\n");
			exit(1);
		}
		if ((newserv->qname = (char *)malloc(strlen(qname) + 1)) == NULL)
		{
			printf("Fatal malloc error!\n");
			exit(2);
		}
		strcpy(newserv->qname, qname);
		newserv->next = curr;
		prev->next = newserv;
		newserv->front = NULL;
	}
	else // server found
	{
		newserv = curr;
	}
	// add a new node to the matching queue
	if ((newreq = (REQUEST *)malloc(sizeof(REQUEST))) == NULL)
	{
		printf("Fatal malloc error!\n");
		exit(3);
	}
	if ((newreq->username = (char *)malloc(strlen(username) + 1)) == NULL)
	{
		printf("Fatal malloc error!\n");
		exit(4);
	}
	strcpy(newreq->username, username);
	newreq->job_id = job_id;
	newreq->next = NULL;

	if (newserv->front == NULL)
	{
		newserv->rear = newserv->front = newreq;
	}
	else
	{
		curr->rear->next = newreq;
		curr->rear = curr->rear->next;
	}
	return;
}

/************************************************************************
    Traverse a list of queues
*/
void traverse(SERVICE *serv_ptr)
{
	REQUEST *reqptr;

	serv_ptr = serv_ptr->next; // skip dummy node
	while (*serv_ptr->qname != DUMMY_TRAILER)
	{
		printf("Service name: %s\n", serv_ptr->qname);
		printf("--------------------\n");
		for (reqptr = serv_ptr->front; reqptr != NULL; reqptr = reqptr->next)
		{
			printf("%-15s %ld\n", reqptr->username, reqptr->job_id );
		}
		putchar('\n');
		serv_ptr = serv_ptr->next;
	}
}



/***************************************************



------------------------------------------------------



 ***************************************************/


/****************************************************************************
**
** BUILDING A RANDOM BINARY SEARCH TREE
**
********************************************************

  Buid a random BST - to test the basic BST operations:
  - traverse // recursive
  - insert   // iterative and recursive
  - search   // iterative and recursive
  - delete
****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX 50

typedef struct nodeTag{
	int data;
	struct nodeTag *left;
	struct nodeTag *right;
} NODE;

int main( void )
{
	NODE *buildBinaryTree( int n );
	void printTreeInorder( NODE *root );
	int insert( NODE **root, int data );
	NODE *find(NODE *root, int target);

	NODE *root, *ptr;
	int   n = 10, s = 10, r;

	srand(time(NULL));
	root = buildBinaryTree( n );
	printTreeInorder( root );

	while (s--)
	{
		r = rand() % MAX;
		ptr = find(root, r);
		if(ptr)
			printf("%3d found: %3d\n", r, ptr->data);
		else
			printf("%3d NOT found!\n", r);
	}
	printf( "\n\n" );
	return 0;
}

/****************************************************************
   INORDER
   Print a BST in Left-Root-Right sequence.
*/
void printTreeInorder( NODE *root )
{
	if( root ){
		printTreeInorder( root->left);
		printf( "%3d",  root->data );
		printTreeInorder( root->right);
	}
	return;
}

/****************************************************************
   Build a random BST of integer numbers within the range
   0 to MAX - 1
*/
NODE *buildBinaryTree( int n )
{
	NODE *root = NULL;
	int   data;

	while(n){
		data   = rand( ) % MAX;
		if(insert(&root, data)) // not a duplicate!
			n--;
	}
	return root;
}

/****************************************************************
   ITERATIVE Insert
*/
int insert( NODE **root, int data )
{
	NODE **ptr_root = root;

	while(*ptr_root){
		if (data > (*ptr_root)->data)
			ptr_root = &(*ptr_root)->right;
		else if (data < (*ptr_root)->data)
			ptr_root = &(*ptr_root)->left;
		else
		{
			printf("Node already in the tree!\n");
			return 0; // duplicate
		}
	}
	if(!(*ptr_root = (NODE *) malloc (sizeof(NODE))))
		printf( "Fatal malloc error!\n" ), exit(1);
	(*ptr_root)->data  = data;
	(*ptr_root)->left  = (*ptr_root)->right = NULL;
	return 1; // data inserted
}

/****************************************************************
   RECURSIVE Insert

int insert( NODE **root, int data )
{

   if(!(*root)){ // parent found: insert data
      // allocate the new node
      if(!(*root = (NODE *) malloc (sizeof(NODE))))
         printf( "Fatal malloc error!\n" ), exit(1);
      (*root)->data  = data;
      (*root)->left  = (*root)->right = NULL;
      return 1; // data inserted
   }

   if (data > (*root)->data)
      return insert(&(*root)->right, data);
   else if (data < (*root)->data)
      return insert(&(*root)->left, data);
   else
   {
       printf("Node already in the tree!\n");
       return 0; // duplicate
   }
}
*/
/****************************************************************
   ITERATIVE Search
*/
NODE *find(NODE *root, int target)
{
	NODE *mover = root;

	while (mover)
	{
		if (target < mover->data)
			mover = mover->left;
		else
		if (target > mover->data)
			mover = mover->right;
		else
			return mover;
	}
	return NULL;
}

/****************************************************************
   RECURSIVE Search

NODE *find(NODE *root, int target)
{
   if (root)
   {
       if (target < root->data)
           return find(root->left, target);
       else
           if (target > root->data)
               return find(root->right, target);
           else
               return root;
   }
   return NULL;
}
*/

/***************************************************



------------------------------------------------------



 ***************************************************/



/*****
CIS 26B - Advanced C Programming
Homework #3:
 Hashing to a file and using advanced string manipulation functions.
 This program allows additions to or displays of a database records.
 NAME: Deniz Erisgen
 IDE: GCC
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define FLUSH while ( getchar()!= '\n');
#define HARDWARE_ID_LEN 4 // Length of hardware identifiers
#define MAX_HARDWARE_NAME_LEN 20 // Maximum length of hardware names.
#define MAX_FILENAME_LEN 30
// Parameters for the database hashtable structure.
#define BUCKET_SIZE 3   // Number of records per hash bucket in the data file
#define NUM_BUCKETS 30  // Number of buckets in the data file.
//  Structure with a hardware record, as it is stored in the database.
typedef struct {
	char id[HARDWARE_ID_LEN + 1];
	char name[MAX_HARDWARE_NAME_LEN + 1];
	int qty;
} HARDWARE;

typedef enum operation { SEARCH, DELETE } OP_TYPE;
typedef enum check { ID, ITEM } CHECK_TYPE;

void interactiveMenu(FILE* fp);

void pMenu();

void createFile(FILE* fp);

void searchOrDelete(char* searchId, FILE* fp, OP_TYPE opType);

int inputParser(char* inputString, FILE* fp, CHECK_TYPE parseType);

void insertItem(HARDWARE* item, FILE* fp);

void addItemsFromFile(char* inputString, FILE* fp);

void printTable(FILE* reader);

int main(int argc, char** argv) {
	char* filename = (argv[1] != NULL) ? argv[1] : "hardware.dat";
	FILE* fp;
	if ((fp = fopen(filename, "r+b")) == NULL) {
		printf("Could not open %s.\n", filename);
		fp = fopen(filename, "w+b");
		createFile(fp);
	}
	// Empty file handling
	fseek(fp, 0, SEEK_END);
	if (ftell(fp) == 0) {
		printf("file is empty\n Creating new table \n");
		createFile(fp);
	}
	interactiveMenu(fp);
	fclose(fp);
	return 0;
}

/********************************************************
 *  Menu Controller to control the program
 *
 *  Input:File ptr to open table file
 *  Output:None
********************************************************/
void interactiveMenu(FILE* fp) {
	char input[MAX_FILENAME_LEN + 1] = "";
	char choice = '1';
	while ( (choice != 'e') && (choice != 'E')) {
		rewind(fp);
		printf("Enter selection (M - menu): ");
		scanf("%1s", &choice);
		FLUSH;
		switch (choice) {
			case 's':
			case 'S':
				printf("Please enter ID : ");
				scanf("%4s", input);
				FLUSH;
				(inputParser(input, fp, ID)) ? searchOrDelete(input, fp, SEARCH) : printf("Please enter 4 digit ID \n");
				break;
			case 'd':
			case 'D':
				printf("Please enter ID : ");
				scanf("%4s", input);
				FLUSH;
				(inputParser(input, fp, ID)) ? searchOrDelete(input, fp, DELETE) : printf("Please enter 4 digit ID \n");
				break;
			case 'i':
			case 'I':
				printf("Please enter \"ID , DESCRIPTION : Quantity\"  : ");
				scanf("%30[^\n]s", input);
				FLUSH;
				(inputParser(input, fp, ITEM)) ? : printf(
				  "Couldn't process \" %s \"\nPlease double check your input\n", input);
				break;
			case 'b':
			case 'B':
				printf("Please enter a filename :");
				scanf("%30[^\n]s", input);
				FLUSH;
				addItemsFromFile(input,fp);
				break;
			case 'm':
			case 'M':
				pMenu();
				break;
			case 't':
			case 'T':
				printTable(fp);
				break;
			case 'e':
			case 'E':
				break;
			default:
				printf("Invalid Entry\nPlease choose a correct command\n");
				pMenu();
		}
		putchar('\n');
	}

}

/********************************************************
 *  Parsing and Cleaning input function
 *
 *
 *  Input:	-input string char array
 *  		-FILE ptr to open table file
 *  		-check type enum that
 *  		-shows the parsing type
 *
 *  ID: 	Searching by ID
 *  ITEM: 	When reading input from console
 *			Removes white space and formats input
 *			to ID,DESCRIPTION:QTY and writes it to
 *			table.
 *
 *  Output:Successful operation Returns 1
********************************************************/
int inputParser(char* inputString, FILE* fp, CHECK_TYPE parseType) {
	char* digits = "0123456789";
	char* approved = " aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTvVuUwWxXyYzZ()";
	char* tkn, * start, * end;
	start = inputString;
	while (*start == ' ') ++start;
	if (start - inputString != 0) strcpy(inputString, start);
	tkn = inputString + HARDWARE_ID_LEN;
	if (strspn(inputString, digits) != HARDWARE_ID_LEN || !(strtol(inputString, &tkn, 10))) return 0;
	if (parseType == ID) return 1;
	start = tkn;
	if (*tkn != ',') {
		*tkn = ',';
		start = tkn + 1;
		if (!(tkn= strrchr(start, ',')) || strspn(tkn,digits) != 0) return 0;
		*tkn = ' ';
		while (*tkn == ' ') ++tkn;
		strcpy(start, tkn);
	} else {
		start = tkn + 1;
		tkn += 2;
		while (*tkn == ' ') ++tkn;
		if (start + 1 != tkn) strcpy(start, tkn);
	}
	if (!(tkn = strrchr(start, ':')) || (strspn(start, approved) != tkn - start)) return 0;
	start = tkn;
	if (*(start -1)  == ' ' && *(start+1) == ' ') {
		tkn = start - 1;
		end = start + 1;
		while (strlen(end) != 0 && *(end) == ' ') end++;
		if (strspn(end, digits) == 0) return 0;
		strcpy(start + 1, end);
		while (*(tkn - 1) == ' ') --tkn;
		strcpy(tkn, start);
	}
	while (*tkn == ' ') ++tkn;
	if (!(strspn(tkn+1,digits))) return 0;
	HARDWARE temp = {};
	tkn = strtok(inputString, ",");
	strcpy(temp.id, tkn);
	tkn = strtok(NULL, ":");
	unsigned i = 0;
	while (tkn[i] != '\0' || i < strlen(tkn)) {
		temp.name[i] = islower(tkn[i]) ? toupper(tkn[i]) : tkn[i];
		i++;
	}
	tkn = strtok(NULL, "\r\n");
	temp.qty = (int) strtol(tkn, NULL, 10);
	insertItem(&temp, fp);

	return 1;
}

/********************************************************
 *  Creates an empty 30 3 struck bucket hashmap in file
 *  Input:File ptr from main with a default file name
 *  "hardware.dat"
 *  Output: None
********************************************************/
void createFile(FILE* fp) {
	HARDWARE items[NUM_BUCKETS][BUCKET_SIZE] = {""};
	if (fwrite(&items[0][0], sizeof(HARDWARE), (NUM_BUCKETS * BUCKET_SIZE), fp) < NUM_BUCKETS) {
		printf("Hash table could not be created. Abort!\n");
		exit(2);
	}
	printf("Creating a new file\n");

	rewind(fp);
}

/********************************************************
 *  Takes an Object and writes it to the table
 *
 *  Input:Ptr to a HARDWARE struct and File ptr to open
 *  table file
 *  Output:None
********************************************************/
void insertItem(HARDWARE* item, FILE* fp) {
	HARDWARE test;
	long address = hash((item->id));
	if (fseek(fp, address * BUCKET_SIZE * sizeof(HARDWARE), SEEK_SET) != 0) {
		printf("Fatal seek error! Abort!\n");
		exit(4);
	}
	for (int i = 0; i < BUCKET_SIZE; i++) {
		fread(&test, sizeof(HARDWARE), 1, fp);
		if (*test.id == '\0') {
			fseek(fp, -1L * sizeof(HARDWARE), SEEK_CUR);
			fwrite(item, sizeof(HARDWARE), 1, fp);
			printf("Record: %s added to  %ld th bucket.\n", item->id, address+1);
			return;
		}else
		if (strcmp(test.id, item->id) == 0) {
			printf("Duplicate entry \n");
			return;
		}
	}
	// item not inserted!
	printf("All buckets are full! %s not added\n", item->id);
}

/********************************************************
 *  Function for searching OR deleting items from Table
 *
 *  Input:char* searchID ,File ptr to open table file
 *  		operation type enum show which operation
 *
 *  Output: None
 *
********************************************************/
void searchOrDelete(char* searchId, FILE* fp, OP_TYPE opType) {
	HARDWARE found;
	long address = hash(searchId);
	if (fseek(fp, address * BUCKET_SIZE * sizeof(HARDWARE), SEEK_SET) != 0) {
		printf("Fatal seek error! Abort!\n");
		exit(4);
	}
	for (int i = 0; i < BUCKET_SIZE; i++) {
		fread(&found, sizeof(HARDWARE), 1, fp);
		if (strcmp(found.id, searchId) == 0) {
			if (opType == DELETE) {
				HARDWARE del = {};
				fseek(fp, -1 * sizeof(HARDWARE), SEEK_CUR);
				fwrite(&del, sizeof(HARDWARE), 1, fp);
				printf("Record %s deleted \n", found.id);
				return;
			}
			printf("Record: %s is %dth item in %ldth bucket\n Name: %s\n", found.id, i + 1, address +1 , found.name);
			return;
		}
	}
	printf("%s not found.\n", searchId);
	rewind(fp);
}

/********************************************************
 *  Reads a file and writes items to the hash table file
 *
 *  Input:input char ptr, file pointer to open hash map
 *  table file
 *
 *  Output:None
********************************************************/
void addItemsFromFile(char* inputString, FILE* fp) {
	FILE* reader;
	char line[MAX_FILENAME_LEN + 1] = "";
	char* tkn;
	HARDWARE temp = {};
	if ((reader = fopen(inputString, "r")) == NULL) {
		printf("Could not open %s.\n", inputString);
		return;//exit(1);
	}
	while (feof(reader) == 0) {
		fgets(line, MAX_FILENAME_LEN, reader);
		tkn = strtok(line, ",");
		strcpy(temp.id, tkn);
		tkn = strtok(NULL, ":");
		strcpy(temp.name, tkn);
		tkn = strtok(NULL, "\r\n");
		temp.qty = (int) strtol(tkn, NULL, 10);
		insertItem(&temp, fp);
	}
	fclose(reader);
}
